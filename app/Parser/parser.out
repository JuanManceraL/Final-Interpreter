Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> code
Rule 2     program -> <empty>
Rule 3     code -> code statement
Rule 4     code -> statement
Rule 5     statement -> declaration
Rule 6     statement -> assignment
Rule 7     statement -> prt
Rule 8     statement -> directives
Rule 9     statement -> ifst
Rule 10    directives -> NS DIRECTIVES LIBRARIES
Rule 11    declaration -> TYPE IDENTIFIER SEMIC
Rule 12    declaration -> TYPE IDENTIFIER EQUALS expression SEMIC
Rule 13    assignment -> IDENTIFIER EQUALS expression SEMIC
Rule 14    prt -> PRINT LPAREN expression RPAREN SEMIC
Rule 15    prt -> PRINT LPAREN STRING RPAREN SEMIC
Rule 16    ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB
Rule 17    ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB
Rule 18    expression -> expression PLUS term
Rule 19    expression -> expression MINUS term
Rule 20    term -> term TIMES factor
Rule 21    term -> term DIVIDE factor
Rule 22    factor -> EXP LPAREN factor value RPAREN
Rule 23    factor -> SQR LPAREN factor RPAREN
Rule 24    value -> NUMBER
Rule 25    valbool -> VAL_BOOL
Rule 26    valbool -> expression OP_BOOL expression
Rule 27    expression -> term
Rule 28    term -> factor
Rule 29    factor -> value
Rule 30    factor -> IDENTIFIER
Rule 31    factor -> LPAREN expression RPAREN
Rule 32    factor -> MINUS factor

Terminals, with rules where they appear

CCURLB               : 16 17 17
DIRECTIVES           : 10
DIVIDE               : 21
ELSE                 : 17
EQUALS               : 12 13
EXP                  : 22
IDENTIFIER           : 11 12 13 30
IF                   : 16 17
LIBRARIES            : 10
LPAREN               : 14 15 16 17 22 23 31
MINUS                : 19 32
NS                   : 10
NUMBER               : 24
OCURLB               : 16 17 17
OP_BOOL              : 26
PLUS                 : 18
PRINT                : 14 15
RPAREN               : 14 15 16 17 22 23 31
SEMIC                : 11 12 13 14 15
SQR                  : 23
STRING               : 15
TIMES                : 20
TYPE                 : 11 12
VAL_BOOL             : 25
error                : 

Nonterminals, with rules where they appear

assignment           : 6
code                 : 1 3
declaration          : 5
directives           : 8
expression           : 12 13 14 18 19 26 26 31
factor               : 20 21 22 23 28 32
ifst                 : 9
program              : 16 17 17 0
prt                  : 7
statement            : 3 4
term                 : 18 19 20 21 27
valbool              : 16 17
value                : 22 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . code
    (2) program -> .
    (3) code -> . code statement
    (4) code -> . statement
    (5) statement -> . declaration
    (6) statement -> . assignment
    (7) statement -> . prt
    (8) statement -> . directives
    (9) statement -> . ifst
    (11) declaration -> . TYPE IDENTIFIER SEMIC
    (12) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (13) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (14) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (15) prt -> . PRINT LPAREN STRING RPAREN SEMIC
    (10) directives -> . NS DIRECTIVES LIBRARIES
    (16) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB
    (17) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB

    $end            reduce using rule 2 (program -> .)
    TYPE            shift and go to state 9
    IDENTIFIER      shift and go to state 10
    PRINT           shift and go to state 11
    NS              shift and go to state 12
    IF              shift and go to state 13

    program                        shift and go to state 1
    code                           shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    prt                            shift and go to state 6
    directives                     shift and go to state 7
    ifst                           shift and go to state 8

state 1

    (0) S' -> program .



state 2

    (1) program -> code .
    (3) code -> code . statement
    (5) statement -> . declaration
    (6) statement -> . assignment
    (7) statement -> . prt
    (8) statement -> . directives
    (9) statement -> . ifst
    (11) declaration -> . TYPE IDENTIFIER SEMIC
    (12) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (13) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (14) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (15) prt -> . PRINT LPAREN STRING RPAREN SEMIC
    (10) directives -> . NS DIRECTIVES LIBRARIES
    (16) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB
    (17) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB

    $end            reduce using rule 1 (program -> code .)
    CCURLB          reduce using rule 1 (program -> code .)
    TYPE            shift and go to state 9
    IDENTIFIER      shift and go to state 10
    PRINT           shift and go to state 11
    NS              shift and go to state 12
    IF              shift and go to state 13

    statement                      shift and go to state 14
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    prt                            shift and go to state 6
    directives                     shift and go to state 7
    ifst                           shift and go to state 8

state 3

    (4) code -> statement .

    TYPE            reduce using rule 4 (code -> statement .)
    IDENTIFIER      reduce using rule 4 (code -> statement .)
    PRINT           reduce using rule 4 (code -> statement .)
    NS              reduce using rule 4 (code -> statement .)
    IF              reduce using rule 4 (code -> statement .)
    $end            reduce using rule 4 (code -> statement .)
    CCURLB          reduce using rule 4 (code -> statement .)


state 4

    (5) statement -> declaration .

    TYPE            reduce using rule 5 (statement -> declaration .)
    IDENTIFIER      reduce using rule 5 (statement -> declaration .)
    PRINT           reduce using rule 5 (statement -> declaration .)
    NS              reduce using rule 5 (statement -> declaration .)
    IF              reduce using rule 5 (statement -> declaration .)
    $end            reduce using rule 5 (statement -> declaration .)
    CCURLB          reduce using rule 5 (statement -> declaration .)


state 5

    (6) statement -> assignment .

    TYPE            reduce using rule 6 (statement -> assignment .)
    IDENTIFIER      reduce using rule 6 (statement -> assignment .)
    PRINT           reduce using rule 6 (statement -> assignment .)
    NS              reduce using rule 6 (statement -> assignment .)
    IF              reduce using rule 6 (statement -> assignment .)
    $end            reduce using rule 6 (statement -> assignment .)
    CCURLB          reduce using rule 6 (statement -> assignment .)


state 6

    (7) statement -> prt .

    TYPE            reduce using rule 7 (statement -> prt .)
    IDENTIFIER      reduce using rule 7 (statement -> prt .)
    PRINT           reduce using rule 7 (statement -> prt .)
    NS              reduce using rule 7 (statement -> prt .)
    IF              reduce using rule 7 (statement -> prt .)
    $end            reduce using rule 7 (statement -> prt .)
    CCURLB          reduce using rule 7 (statement -> prt .)


state 7

    (8) statement -> directives .

    TYPE            reduce using rule 8 (statement -> directives .)
    IDENTIFIER      reduce using rule 8 (statement -> directives .)
    PRINT           reduce using rule 8 (statement -> directives .)
    NS              reduce using rule 8 (statement -> directives .)
    IF              reduce using rule 8 (statement -> directives .)
    $end            reduce using rule 8 (statement -> directives .)
    CCURLB          reduce using rule 8 (statement -> directives .)


state 8

    (9) statement -> ifst .

    TYPE            reduce using rule 9 (statement -> ifst .)
    IDENTIFIER      reduce using rule 9 (statement -> ifst .)
    PRINT           reduce using rule 9 (statement -> ifst .)
    NS              reduce using rule 9 (statement -> ifst .)
    IF              reduce using rule 9 (statement -> ifst .)
    $end            reduce using rule 9 (statement -> ifst .)
    CCURLB          reduce using rule 9 (statement -> ifst .)


state 9

    (11) declaration -> TYPE . IDENTIFIER SEMIC
    (12) declaration -> TYPE . IDENTIFIER EQUALS expression SEMIC

    IDENTIFIER      shift and go to state 15


state 10

    (13) assignment -> IDENTIFIER . EQUALS expression SEMIC

    EQUALS          shift and go to state 16


state 11

    (14) prt -> PRINT . LPAREN expression RPAREN SEMIC
    (15) prt -> PRINT . LPAREN STRING RPAREN SEMIC

    LPAREN          shift and go to state 17


state 12

    (10) directives -> NS . DIRECTIVES LIBRARIES

    DIRECTIVES      shift and go to state 18


state 13

    (16) ifst -> IF . LPAREN valbool RPAREN OCURLB program CCURLB
    (17) ifst -> IF . LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB

    LPAREN          shift and go to state 19


state 14

    (3) code -> code statement .

    TYPE            reduce using rule 3 (code -> code statement .)
    IDENTIFIER      reduce using rule 3 (code -> code statement .)
    PRINT           reduce using rule 3 (code -> code statement .)
    NS              reduce using rule 3 (code -> code statement .)
    IF              reduce using rule 3 (code -> code statement .)
    $end            reduce using rule 3 (code -> code statement .)
    CCURLB          reduce using rule 3 (code -> code statement .)


state 15

    (11) declaration -> TYPE IDENTIFIER . SEMIC
    (12) declaration -> TYPE IDENTIFIER . EQUALS expression SEMIC

    SEMIC           shift and go to state 20
    EQUALS          shift and go to state 21


state 16

    (13) assignment -> IDENTIFIER EQUALS . expression SEMIC
    (18) expression -> . expression PLUS term
    (19) expression -> . expression MINUS term
    (27) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    expression                     shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 17

    (14) prt -> PRINT LPAREN . expression RPAREN SEMIC
    (15) prt -> PRINT LPAREN . STRING RPAREN SEMIC
    (18) expression -> . expression PLUS term
    (19) expression -> . expression MINUS term
    (27) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    STRING          shift and go to state 33
    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    expression                     shift and go to state 32
    term                           shift and go to state 24
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 18

    (10) directives -> NS DIRECTIVES . LIBRARIES

    LIBRARIES       shift and go to state 34


state 19

    (16) ifst -> IF LPAREN . valbool RPAREN OCURLB program CCURLB
    (17) ifst -> IF LPAREN . valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB
    (25) valbool -> . VAL_BOOL
    (26) valbool -> . expression OP_BOOL expression
    (18) expression -> . expression PLUS term
    (19) expression -> . expression MINUS term
    (27) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    VAL_BOOL        shift and go to state 36
    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    valbool                        shift and go to state 35
    expression                     shift and go to state 37
    term                           shift and go to state 24
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 20

    (11) declaration -> TYPE IDENTIFIER SEMIC .

    TYPE            reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)
    IDENTIFIER      reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)
    PRINT           reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)
    NS              reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)
    IF              reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)
    $end            reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)
    CCURLB          reduce using rule 11 (declaration -> TYPE IDENTIFIER SEMIC .)


state 21

    (12) declaration -> TYPE IDENTIFIER EQUALS . expression SEMIC
    (18) expression -> . expression PLUS term
    (19) expression -> . expression MINUS term
    (27) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    expression                     shift and go to state 38
    term                           shift and go to state 24
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 22

    (30) factor -> IDENTIFIER .

    TIMES           reduce using rule 30 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 30 (factor -> IDENTIFIER .)
    SEMIC           reduce using rule 30 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 30 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 30 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 30 (factor -> IDENTIFIER .)
    OP_BOOL         reduce using rule 30 (factor -> IDENTIFIER .)
    NUMBER          reduce using rule 30 (factor -> IDENTIFIER .)


state 23

    (13) assignment -> IDENTIFIER EQUALS expression . SEMIC
    (18) expression -> expression . PLUS term
    (19) expression -> expression . MINUS term

    SEMIC           shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 24

    (27) expression -> term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    SEMIC           reduce using rule 27 (expression -> term .)
    PLUS            reduce using rule 27 (expression -> term .)
    MINUS           reduce using rule 27 (expression -> term .)
    RPAREN          reduce using rule 27 (expression -> term .)
    OP_BOOL         reduce using rule 27 (expression -> term .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43


state 25

    (32) factor -> MINUS . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    factor                         shift and go to state 44
    value                          shift and go to state 29

state 26

    (28) term -> factor .

    TIMES           reduce using rule 28 (term -> factor .)
    DIVIDE          reduce using rule 28 (term -> factor .)
    SEMIC           reduce using rule 28 (term -> factor .)
    PLUS            reduce using rule 28 (term -> factor .)
    MINUS           reduce using rule 28 (term -> factor .)
    RPAREN          reduce using rule 28 (term -> factor .)
    OP_BOOL         reduce using rule 28 (term -> factor .)


state 27

    (22) factor -> EXP . LPAREN factor value RPAREN

    LPAREN          shift and go to state 45


state 28

    (31) factor -> LPAREN . expression RPAREN
    (18) expression -> . expression PLUS term
    (19) expression -> . expression MINUS term
    (27) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    expression                     shift and go to state 46
    term                           shift and go to state 24
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 29

    (29) factor -> value .

    TIMES           reduce using rule 29 (factor -> value .)
    DIVIDE          reduce using rule 29 (factor -> value .)
    SEMIC           reduce using rule 29 (factor -> value .)
    PLUS            reduce using rule 29 (factor -> value .)
    MINUS           reduce using rule 29 (factor -> value .)
    RPAREN          reduce using rule 29 (factor -> value .)
    OP_BOOL         reduce using rule 29 (factor -> value .)
    NUMBER          reduce using rule 29 (factor -> value .)


state 30

    (23) factor -> SQR . LPAREN factor RPAREN

    LPAREN          shift and go to state 47


state 31

    (24) value -> NUMBER .

    TIMES           reduce using rule 24 (value -> NUMBER .)
    DIVIDE          reduce using rule 24 (value -> NUMBER .)
    SEMIC           reduce using rule 24 (value -> NUMBER .)
    PLUS            reduce using rule 24 (value -> NUMBER .)
    MINUS           reduce using rule 24 (value -> NUMBER .)
    RPAREN          reduce using rule 24 (value -> NUMBER .)
    OP_BOOL         reduce using rule 24 (value -> NUMBER .)
    NUMBER          reduce using rule 24 (value -> NUMBER .)


state 32

    (14) prt -> PRINT LPAREN expression . RPAREN SEMIC
    (18) expression -> expression . PLUS term
    (19) expression -> expression . MINUS term

    RPAREN          shift and go to state 48
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 33

    (15) prt -> PRINT LPAREN STRING . RPAREN SEMIC

    RPAREN          shift and go to state 49


state 34

    (10) directives -> NS DIRECTIVES LIBRARIES .

    TYPE            reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)
    IDENTIFIER      reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)
    PRINT           reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)
    NS              reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)
    IF              reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)
    $end            reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)
    CCURLB          reduce using rule 10 (directives -> NS DIRECTIVES LIBRARIES .)


state 35

    (16) ifst -> IF LPAREN valbool . RPAREN OCURLB program CCURLB
    (17) ifst -> IF LPAREN valbool . RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB

    RPAREN          shift and go to state 50


state 36

    (25) valbool -> VAL_BOOL .

    RPAREN          reduce using rule 25 (valbool -> VAL_BOOL .)


state 37

    (26) valbool -> expression . OP_BOOL expression
    (18) expression -> expression . PLUS term
    (19) expression -> expression . MINUS term

    OP_BOOL         shift and go to state 51
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 38

    (12) declaration -> TYPE IDENTIFIER EQUALS expression . SEMIC
    (18) expression -> expression . PLUS term
    (19) expression -> expression . MINUS term

    SEMIC           shift and go to state 52
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 39

    (13) assignment -> IDENTIFIER EQUALS expression SEMIC .

    TYPE            reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    IDENTIFIER      reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    PRINT           reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    NS              reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    IF              reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    $end            reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)
    CCURLB          reduce using rule 13 (assignment -> IDENTIFIER EQUALS expression SEMIC .)


state 40

    (18) expression -> expression PLUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    term                           shift and go to state 53
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 41

    (19) expression -> expression MINUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    term                           shift and go to state 54
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 42

    (20) term -> term TIMES . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    factor                         shift and go to state 55
    value                          shift and go to state 29

state 43

    (21) term -> term DIVIDE . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    factor                         shift and go to state 56
    value                          shift and go to state 29

state 44

    (32) factor -> MINUS factor .

    TIMES           reduce using rule 32 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 32 (factor -> MINUS factor .)
    SEMIC           reduce using rule 32 (factor -> MINUS factor .)
    PLUS            reduce using rule 32 (factor -> MINUS factor .)
    MINUS           reduce using rule 32 (factor -> MINUS factor .)
    RPAREN          reduce using rule 32 (factor -> MINUS factor .)
    OP_BOOL         reduce using rule 32 (factor -> MINUS factor .)
    NUMBER          reduce using rule 32 (factor -> MINUS factor .)


state 45

    (22) factor -> EXP LPAREN . factor value RPAREN
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    factor                         shift and go to state 57
    value                          shift and go to state 29

state 46

    (31) factor -> LPAREN expression . RPAREN
    (18) expression -> expression . PLUS term
    (19) expression -> expression . MINUS term

    RPAREN          shift and go to state 58
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 47

    (23) factor -> SQR LPAREN . factor RPAREN
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    factor                         shift and go to state 59
    value                          shift and go to state 29

state 48

    (14) prt -> PRINT LPAREN expression RPAREN . SEMIC

    SEMIC           shift and go to state 60


state 49

    (15) prt -> PRINT LPAREN STRING RPAREN . SEMIC

    SEMIC           shift and go to state 61


state 50

    (16) ifst -> IF LPAREN valbool RPAREN . OCURLB program CCURLB
    (17) ifst -> IF LPAREN valbool RPAREN . OCURLB program CCURLB ELSE OCURLB program CCURLB

    OCURLB          shift and go to state 62


state 51

    (26) valbool -> expression OP_BOOL . expression
    (18) expression -> . expression PLUS term
    (19) expression -> . expression MINUS term
    (27) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (28) term -> . factor
    (22) factor -> . EXP LPAREN factor value RPAREN
    (23) factor -> . SQR LPAREN factor RPAREN
    (29) factor -> . value
    (30) factor -> . IDENTIFIER
    (31) factor -> . LPAREN expression RPAREN
    (32) factor -> . MINUS factor
    (24) value -> . NUMBER

    EXP             shift and go to state 27
    SQR             shift and go to state 30
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 28
    MINUS           shift and go to state 25
    NUMBER          shift and go to state 31

    expression                     shift and go to state 63
    term                           shift and go to state 24
    factor                         shift and go to state 26
    value                          shift and go to state 29

state 52

    (12) declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .

    TYPE            reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    IDENTIFIER      reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    PRINT           reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    NS              reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    IF              reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    $end            reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)
    CCURLB          reduce using rule 12 (declaration -> TYPE IDENTIFIER EQUALS expression SEMIC .)


state 53

    (18) expression -> expression PLUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    SEMIC           reduce using rule 18 (expression -> expression PLUS term .)
    PLUS            reduce using rule 18 (expression -> expression PLUS term .)
    MINUS           reduce using rule 18 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 18 (expression -> expression PLUS term .)
    OP_BOOL         reduce using rule 18 (expression -> expression PLUS term .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43


state 54

    (19) expression -> expression MINUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    SEMIC           reduce using rule 19 (expression -> expression MINUS term .)
    PLUS            reduce using rule 19 (expression -> expression MINUS term .)
    MINUS           reduce using rule 19 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 19 (expression -> expression MINUS term .)
    OP_BOOL         reduce using rule 19 (expression -> expression MINUS term .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43


state 55

    (20) term -> term TIMES factor .

    TIMES           reduce using rule 20 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 20 (term -> term TIMES factor .)
    SEMIC           reduce using rule 20 (term -> term TIMES factor .)
    PLUS            reduce using rule 20 (term -> term TIMES factor .)
    MINUS           reduce using rule 20 (term -> term TIMES factor .)
    RPAREN          reduce using rule 20 (term -> term TIMES factor .)
    OP_BOOL         reduce using rule 20 (term -> term TIMES factor .)


state 56

    (21) term -> term DIVIDE factor .

    TIMES           reduce using rule 21 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 21 (term -> term DIVIDE factor .)
    SEMIC           reduce using rule 21 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 21 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 21 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 21 (term -> term DIVIDE factor .)
    OP_BOOL         reduce using rule 21 (term -> term DIVIDE factor .)


state 57

    (22) factor -> EXP LPAREN factor . value RPAREN
    (24) value -> . NUMBER

    NUMBER          shift and go to state 31

    value                          shift and go to state 64

state 58

    (31) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    SEMIC           reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    OP_BOOL         reduce using rule 31 (factor -> LPAREN expression RPAREN .)
    NUMBER          reduce using rule 31 (factor -> LPAREN expression RPAREN .)


state 59

    (23) factor -> SQR LPAREN factor . RPAREN

    RPAREN          shift and go to state 65


state 60

    (14) prt -> PRINT LPAREN expression RPAREN SEMIC .

    TYPE            reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    IDENTIFIER      reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    PRINT           reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    NS              reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    IF              reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    $end            reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)
    CCURLB          reduce using rule 14 (prt -> PRINT LPAREN expression RPAREN SEMIC .)


state 61

    (15) prt -> PRINT LPAREN STRING RPAREN SEMIC .

    TYPE            reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)
    IDENTIFIER      reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)
    PRINT           reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)
    NS              reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)
    IF              reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)
    $end            reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)
    CCURLB          reduce using rule 15 (prt -> PRINT LPAREN STRING RPAREN SEMIC .)


state 62

    (16) ifst -> IF LPAREN valbool RPAREN OCURLB . program CCURLB
    (17) ifst -> IF LPAREN valbool RPAREN OCURLB . program CCURLB ELSE OCURLB program CCURLB
    (1) program -> . code
    (2) program -> .
    (3) code -> . code statement
    (4) code -> . statement
    (5) statement -> . declaration
    (6) statement -> . assignment
    (7) statement -> . prt
    (8) statement -> . directives
    (9) statement -> . ifst
    (11) declaration -> . TYPE IDENTIFIER SEMIC
    (12) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (13) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (14) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (15) prt -> . PRINT LPAREN STRING RPAREN SEMIC
    (10) directives -> . NS DIRECTIVES LIBRARIES
    (16) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB
    (17) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB

    CCURLB          reduce using rule 2 (program -> .)
    TYPE            shift and go to state 9
    IDENTIFIER      shift and go to state 10
    PRINT           shift and go to state 11
    NS              shift and go to state 12
    IF              shift and go to state 13

    program                        shift and go to state 66
    code                           shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    prt                            shift and go to state 6
    directives                     shift and go to state 7
    ifst                           shift and go to state 8

state 63

    (26) valbool -> expression OP_BOOL expression .
    (18) expression -> expression . PLUS term
    (19) expression -> expression . MINUS term

    RPAREN          reduce using rule 26 (valbool -> expression OP_BOOL expression .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 64

    (22) factor -> EXP LPAREN factor value . RPAREN

    RPAREN          shift and go to state 67


state 65

    (23) factor -> SQR LPAREN factor RPAREN .

    TIMES           reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    DIVIDE          reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    SEMIC           reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    PLUS            reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    MINUS           reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    RPAREN          reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    OP_BOOL         reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)
    NUMBER          reduce using rule 23 (factor -> SQR LPAREN factor RPAREN .)


state 66

    (16) ifst -> IF LPAREN valbool RPAREN OCURLB program . CCURLB
    (17) ifst -> IF LPAREN valbool RPAREN OCURLB program . CCURLB ELSE OCURLB program CCURLB

    CCURLB          shift and go to state 68


state 67

    (22) factor -> EXP LPAREN factor value RPAREN .

    TIMES           reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    DIVIDE          reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    SEMIC           reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    PLUS            reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    MINUS           reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    RPAREN          reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    OP_BOOL         reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)
    NUMBER          reduce using rule 22 (factor -> EXP LPAREN factor value RPAREN .)


state 68

    (16) ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .
    (17) ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB . ELSE OCURLB program CCURLB

    TYPE            reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    IDENTIFIER      reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    PRINT           reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    NS              reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    IF              reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    $end            reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    CCURLB          reduce using rule 16 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB .)
    ELSE            shift and go to state 69


state 69

    (17) ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE . OCURLB program CCURLB

    OCURLB          shift and go to state 70


state 70

    (17) ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB . program CCURLB
    (1) program -> . code
    (2) program -> .
    (3) code -> . code statement
    (4) code -> . statement
    (5) statement -> . declaration
    (6) statement -> . assignment
    (7) statement -> . prt
    (8) statement -> . directives
    (9) statement -> . ifst
    (11) declaration -> . TYPE IDENTIFIER SEMIC
    (12) declaration -> . TYPE IDENTIFIER EQUALS expression SEMIC
    (13) assignment -> . IDENTIFIER EQUALS expression SEMIC
    (14) prt -> . PRINT LPAREN expression RPAREN SEMIC
    (15) prt -> . PRINT LPAREN STRING RPAREN SEMIC
    (10) directives -> . NS DIRECTIVES LIBRARIES
    (16) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB
    (17) ifst -> . IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB

    CCURLB          reduce using rule 2 (program -> .)
    TYPE            shift and go to state 9
    IDENTIFIER      shift and go to state 10
    PRINT           shift and go to state 11
    NS              shift and go to state 12
    IF              shift and go to state 13

    program                        shift and go to state 71
    code                           shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    prt                            shift and go to state 6
    directives                     shift and go to state 7
    ifst                           shift and go to state 8

state 71

    (17) ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program . CCURLB

    CCURLB          shift and go to state 72


state 72

    (17) ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .

    TYPE            reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)
    IDENTIFIER      reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)
    PRINT           reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)
    NS              reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)
    IF              reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)
    $end            reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)
    CCURLB          reduce using rule 17 (ifst -> IF LPAREN valbool RPAREN OCURLB program CCURLB ELSE OCURLB program CCURLB .)

